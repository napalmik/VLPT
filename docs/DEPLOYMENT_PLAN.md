# План вывода проекта в интернет

Этот документ — рабочий roadmap, по которому будем по шагам делать проект доступным из интернета.

## 1) Цель и ожидаемый результат

- Проект доступен по домену (например, `app.example.com`).
- Frontend открывается по HTTPS.
- Backend API работает за reverse proxy и недоступен напрямую снаружи.
- База данных доступна только внутри сервера (без публичного порта).
- Есть базовая безопасность, логирование, резервное копирование и понятный процесс обновления.

## 2) Текущая база (что уже есть)

- Монорепозиторий с `frontend` (React + Vite), `backend` (Node.js + Express + TypeScript), `database` (MySQL).
- Есть `docker-compose.yml` для локальной разработки.
- Сервисы: `db`, `backend`, `frontend`.

## 3) Целевая архитектура в проде

- VPS (Linux, Ubuntu 22.04 LTS).
- Docker + Docker Compose.
- Nginx как reverse proxy:
  - `https://app.domain` -> frontend container.
  - `https://app.domain/api` -> backend container.
- SSL-сертификат от Let's Encrypt (автообновление).
- MySQL в отдельном контейнере без публикации `3306` во внешний интернет.

## 4) Пошаговый план работ

## Этап A. Подготовка инфраструктуры

- [ ] Выбрать хостинг/VPS (2 vCPU, 2-4 GB RAM минимум).
- [ ] Зарегистрировать домен или субдомен.
- [ ] Настроить DNS A-запись на IP сервера.
- [ ] Подготовить доступ по SSH (ключи, отключить password auth).

## Этап B. Подготовка production-конфигов

- [ ] Создать отдельный `docker-compose.prod.yml`.
- [ ] Добавить Dockerfile для `backend` (production build).
- [ ] Добавить Dockerfile для `frontend` (build + раздача статики через nginx/caddy или node static).
- [ ] Подготовить `.env.production` (без коммита секретов в git).
- [ ] Вынести секреты:
  - [ ] `JWT_SECRET`
  - [ ] пароли БД
  - [ ] SMTP/почтовые ключи (если используются)
- [ ] Отключить проброс порта MySQL наружу.

## Этап C. Reverse proxy и HTTPS

- [ ] Поднять Nginx (как контейнер или пакет на хосте).
- [ ] Настроить проксирование:
  - [ ] `/` -> frontend
  - [ ] `/api` -> backend
- [ ] Настроить SSL через Let's Encrypt (certbot или nginx-proxy-manager).
- [ ] Включить редирект HTTP -> HTTPS.
- [ ] Проверить CORS/прокси-настройки backend под production-домен.

## Этап D. Деплой и запуск

- [ ] Установить на сервер:
  - [ ] Docker
  - [ ] Docker Compose plugin
- [ ] Скопировать проект на сервер (git clone).
- [ ] Заполнить `.env.production`.
- [ ] Запустить `docker compose -f docker-compose.prod.yml up -d --build`.
- [ ] Проверить health-check и логи контейнеров.
- [ ] Проверить доступность:
  - [ ] главная страница
  - [ ] авторизация
  - [ ] ключевые API-эндпоинты

## Этап E. Базовая безопасность

- [ ] Закрыть лишние порты в firewall (`ufw`):
  - [ ] оставить только `22`, `80`, `443`.
- [ ] Включить `fail2ban`.
- [ ] Ограничить размер запросов в Nginx.
- [ ] Включить security headers (HSTS, X-Frame-Options, X-Content-Type-Options).
- [ ] Проверить, что debug/dev режимы отключены в проде.

## Этап F. Поддержка и надежность

- [ ] Настроить ротацию логов Docker.
- [ ] Настроить backup БД (ежедневно, хранение минимум 7-14 дней).
- [ ] Добавить uptime-проверку (например, Uptime Kuma).
- [ ] Добавить простой rollback-сценарий (возврат на прошлый docker image/tag).
- [ ] Описать регламент обновления версии.

## Этап G. CI/CD (после стабильного ручного деплоя)

- [ ] GitHub Actions/GitLab CI:
  - [ ] сборка и тесты
  - [ ] сборка docker image
  - [ ] push в registry
  - [ ] деплой на сервер по SSH
- [ ] Разделить окружения `staging` и `production` (по возможности).

## 5) Что сделаем в первую очередь (приоритет)

1. Подготовим `docker-compose.prod.yml`.
2. Настроим production Dockerfile для frontend и backend.
3. Настроим Nginx + HTTPS.
4. Выполним первый ручной деплой на VPS.
5. После стабилизации добавим backup и CI/CD.

## 6) Критерии готовности (Definition of Done)

- Сайт открывается по HTTPS без предупреждений браузера.
- API отвечает стабильно через домен.
- MySQL не торчит наружу.
- Секреты не хранятся в репозитории.
- Есть инструкции по обновлению и восстановлению.

## 7) Риски и как снизить

- Риск: утечка секретов -> использовать `.env.production`, не коммитить, регулярно ротировать ключи.
- Риск: потеря данных -> автоматические бэкапы + тест восстановления.
- Риск: downtime при обновлениях -> staging/проверка перед релизом + rollback.
- Риск: рост нагрузки -> мониторинг CPU/RAM/DB и план масштабирования.

## 8) Рабочий формат

По этому файлу идем сверху вниз:

- выбираем этап;
- выполняем пункты чеклиста;
- фиксируем, что сделано;
- переходим к следующему этапу.

